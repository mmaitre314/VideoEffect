<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Video Effects by mmaitre314</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/mmaitre314/VideoEffect">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/mmaitre314/VideoEffect/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/mmaitre314/VideoEffect/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Video Effects</h1>
          <p></p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/mmaitre314">mmaitre314</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <p><a href="https://ci.appveyor.com/project/mmaitre314/videoeffect"><img src="https://ci.appveyor.com/api/projects/status/vkkt3t5i4av2trs0?svg=true" alt="Build status"></a>
<a href="https://www.nuget.org/packages/MMaitre.VideoEffects/"><img src="http://mmaitre314.github.io/images/nuget.png" alt="NuGet package"></a></p>

<table>
<thead>
<tr>
<th>Original</th>
<th>Antique + HorizontalFlip</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="http://mmaitre314.github.io/VideoEffect/car_original.jpg" alt="Original"></td>
<td><img src="http://mmaitre314.github.io/VideoEffect/car_processed.jpg" alt="Processed"></td>
</tr>
</tbody>
</table>

<p>Apply image effects from the <a href="http://developer.nokia.com/resources/library/Imaging_API_Ref/index.html">Nokia Imaging SDK</a> and <a href="http://msdn.microsoft.com/en-us/library/bb509635(v=VS.85).aspx">DirectX HLSL pixel shaders</a> to videos in <a href="http://msdn.microsoft.com/en-us/library/windows/apps/dn609832.aspx">Universal Store Apps</a> for Windows Phone 8.1 and Windows 8.1.</p>

<p>Effects can be applied via <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.media.transcoding.mediatranscoder.aspx">MediaTranscoder</a>, <a href="http://msdn.microsoft.com/en-us/library/windows/apps/xaml/windows.media.editing.mediacomposition.aspx">MediaComposition</a>, <a href="http://msdn.microsoft.com/en-us/library/windows/apps/xaml/windows.media.capture.mediacapture.aspx">MediaCapture</a>, or <a href="http://msdn.microsoft.com/en-us/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx">MediaElement</a>.</p>

<p>Binaries are available via <a href="https://www.nuget.org/packages/MMaitre.VideoEffects/">NuGet</a>.</p>

<h2>
<a id="nokia-imaging-sdk-effects" class="anchor" href="#nokia-imaging-sdk-effects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nokia Imaging SDK effects</h2>

<p>A video effect definition is created from a chain of image effects and passed to a video-processing class like MediaTranscoder:</p>

<div class="highlight highlight-c#"><pre><span class="pl-k">var</span> definition = <span class="pl-s">new</span> LumiaEffectDefinition(() =&gt;
{
    <span class="pl-k">return</span> <span class="pl-s">new</span> IFilter[]
    {
        <span class="pl-s">new</span> AntiqueFilter(),
        <span class="pl-s">new</span> FlipFilter(FlipMode.Horizontal)
    };
});

<span class="pl-k">var</span> transcoder = <span class="pl-s">new</span> MediaTranscoder();
transcoder.AddVideoEffect(definition.ActivatableClassId, <span class="pl-c1">true</span>, definition.Properties);</pre></div>

<h3>
<a id="square-videos" class="anchor" href="#square-videos" aria-hidden="true"><span class="octicon octicon-link"></span></a>Square videos</h3>

<p>Image effects changing the image resolution -- cropping for instance -- are also supported. In that case the resolutions of the input and output of the effect need to be specified explicitly. For instance, the following code snippet creates a square video:</p>

<div class="highlight highlight-c#"><pre><span class="pl-c">// Select the largest centered square area in the input video</span>
<span class="pl-k">var</span> encodingProfile = await TranscodingProfile.CreateFromFileAsync(file);
<span class="pl-st">uint</span> inputWidth = encodingProfile.Video.Width;
<span class="pl-st">uint</span> inputHeight = encodingProfile.Video.Height;
<span class="pl-st">uint</span> outputLength = Math.Min(inputWidth, inputHeight);
Rect cropArea = <span class="pl-s">new</span> Rect(
    (<span class="pl-st">float</span>)((inputWidth - outputLength) / <span class="pl-c1">2</span>),
    (<span class="pl-st">float</span>)((inputHeight - outputLength) / <span class="pl-c1">2</span>),
    (<span class="pl-st">float</span>)outputLength,
    (<span class="pl-st">float</span>)outputLength
);

<span class="pl-k">var</span> definition = <span class="pl-s">new</span> LumiaEffectDefinition(() =&gt;
{
    <span class="pl-k">return</span> <span class="pl-s">new</span> IFilter[]
    {
        <span class="pl-s">new</span> CropFilter(cropArea)
    };
});
definition.InputWidth = inputWidth;
definition.InputHeight = inputHeight;
definition.OutputWidth = outputLength;
definition.OutputHeight = outputLength;</pre></div>

<p>Note: in Windows Phone 8.1 a bug in MediaComposition prevents the width/height information to be properly passed to the effect.</p>

<h3>
<a id="overlays" class="anchor" href="#overlays" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overlays</h3>

<p>BlendFilter can overlay an image on top of a video: </p>

<div class="highlight highlight-c#"><pre><span class="pl-k">var</span> file = await StorageFile.GetFileFromApplicationUriAsync(<span class="pl-s">new</span> Uri(<span class="pl-s1"><span class="pl-pds">"</span>ms-appx:///Assets/traffic.png<span class="pl-pds">"</span></span>));
<span class="pl-k">var</span> foreground = <span class="pl-s">new</span> StorageFileImageSource(file);
<span class="pl-k">var</span> definition = <span class="pl-s">new</span> LumiaEffectDefinition(() =&gt;
{
    <span class="pl-k">var</span> filter = <span class="pl-s">new</span> BlendFilter(foreground);
    filter.TargetOutputOption = OutputOption.PreserveAspectRatio;
    filter.TargetArea = <span class="pl-s">new</span> Rect(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, .<span class="pl-c1">4</span>, .<span class="pl-c1">4</span>);
    <span class="pl-k">return</span> <span class="pl-s">new</span> IFilter[] { filter };
});</pre></div>

<h3>
<a id="animations" class="anchor" href="#animations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Animations</h3>

<p>The LumiaEffectDefinition() constructor is overloaded to support effects whose properties vary based on time. This requires creating a class implementing the IAnimatedFilterChain interface, with a 'Filters' property returning the current effect chain and an 'UpdateTime()' method receiving the current time. </p>

<div class="highlight highlight-c#"><pre><span class="pl-s">class</span> <span class="pl-en">AnimatedWarp</span> : <span class="pl-st">IAnimatedFilterChain</span>
{
    WarpFilter _filter = <span class="pl-s">new</span> WarpFilter(WarpEffect.Twister, <span class="pl-c1">0</span>);

    <span class="pl-s">public</span> IEnumerable&lt;IFilter&gt; <span class="pl-en">Filters</span> { <span class="pl-k">get</span>; <span class="pl-s">private</span> <span class="pl-k">set</span>; }

    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">UpdateTime</span>(<span class="pl-st">TimeSpan</span> <span class="pl-vpf">time</span>)
    {
        _filter.Level = .<span class="pl-c1">5</span> * (Math.Sin(<span class="pl-c1">2</span> * Math.PI * time.TotalSeconds) + <span class="pl-c1">1</span>); <span class="pl-c">// 1Hz oscillation between 0 and 1</span>
    }

    <span class="pl-s">public</span> <span class="pl-en">AnimatedWarp</span>()
    {
        Filters = <span class="pl-s">new</span> List&lt;IFilter&gt; { _filter };
    }
}

<span class="pl-k">var</span> definition = <span class="pl-s">new</span> LumiaEffectDefinition(() =&gt;
{
    <span class="pl-k">return</span> <span class="pl-s">new</span> AnimatedWarp();
});</pre></div>

<h3>
<a id="bitmaps-and-pixel-data" class="anchor" href="#bitmaps-and-pixel-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bitmaps and pixel data</h3>

<p>For cases where IFilter is not flexible enough, another overload of the LumiaEffectDefinition() constructor supports effects which handle Bitmap objects directly. This requires implementing IBitmapVideoEffect, which has a single Process() method called with an input bitmap, an output bitmap, and the current time for each frame in the video.</p>

<p>The bitmaps passed to the Process() call get destroyed when the call returns, so any async call in this method must be executed synchronously using '.AsTask().Wait()'.</p>

<p>The following code snippet shows how to apply a watercolor effect to the video:</p>

<div class="highlight highlight-c#"><pre><span class="pl-s">class</span> <span class="pl-en">WatercolorEffect</span> : <span class="pl-st">IBitmapVideoEffect</span>
{
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">Process</span>(<span class="pl-st">Bitmap</span> <span class="pl-vpf">input</span>, <span class="pl-st">Bitmap</span> <span class="pl-vpf">output</span>, <span class="pl-st">TimeSpan</span> <span class="pl-vpf">time</span>)
    {
        <span class="pl-k">var</span> effect = <span class="pl-s">new</span> FilterEffect();
        effect.Filters = <span class="pl-s">new</span> IFilter[]{ <span class="pl-s">new</span> WatercolorFilter() };
        effect.Source = <span class="pl-s">new</span> BitmapImageSource(input);
        <span class="pl-k">var</span> renderer = <span class="pl-s">new</span> BitmapRenderer(effect, output);
        renderer.RenderAsync().AsTask().Wait(); <span class="pl-c">// Async calls must run sync inside Process()</span>
    }
}

<span class="pl-k">var</span> definition = <span class="pl-s">new</span> LumiaEffectDefinition(() =&gt;
{
    <span class="pl-k">return</span> <span class="pl-s">new</span> WatercolorEffect();
});</pre></div>

<p>IBitmapVideoEffect also allows raw pixel-data processing. Pixel data is provided in Bgra888 format (32 bits per pixel). The content of the alpha channel is undefined and should not be used.</p>

<p>For efficiency, a GetData() method extension is provided on IBuffer. It is enabled by adding a 'using VideoEffectExtensions;' statement. GetData() returns an 'unsafe' byte* pointing to the IBuffer data. This requires methods calling GetData() to be marked using the 'unsafe' keyword and to check the 'Allow unsafe code' checkbox in the project build properties.</p>

<p>The following code snippet shows how to apply a blue filter by setting both the red and green channels to zero:</p>

<div class="highlight highlight-c#"><pre><span class="pl-k">using</span> VideoEffectExtensions;

<span class="pl-s">class</span> <span class="pl-en">BlueEffect</span> : <span class="pl-st">IBitmapVideoEffect</span>
{
    <span class="pl-s">public</span> <span class="pl-s">unsafe</span> <span class="pl-st">void</span> <span class="pl-en">Process</span>(<span class="pl-st">Bitmap</span> <span class="pl-vpf">input</span>, <span class="pl-st">Bitmap</span> <span class="pl-vpf">output</span>, <span class="pl-st">TimeSpan</span> <span class="pl-vpf">time</span>)
    {
        <span class="pl-st">uint</span> width = (<span class="pl-st">uint</span>)input.Dimensions.Width;
        <span class="pl-st">uint</span> height = (<span class="pl-st">uint</span>)input.Dimensions.Height;

        <span class="pl-st">uint</span>  inputPitch = input.Buffers[<span class="pl-c1">0</span>].Pitch;
        <span class="pl-st">byte</span>* inputData  = input.Buffers[<span class="pl-c1">0</span>].Buffer.GetData();
        <span class="pl-st">uint</span>  outputPitch = output.Buffers[<span class="pl-c1">0</span>].Pitch;
        <span class="pl-st">byte</span>* outputData  = output.Buffers[<span class="pl-c1">0</span>].Buffer.GetData();

        <span class="pl-k">for</span> (<span class="pl-st">uint</span> i = <span class="pl-c1">0</span>; i &lt; height; i++)
        {
            <span class="pl-k">for</span> (<span class="pl-st">uint</span> j = <span class="pl-c1">0</span>; j &lt; width; j++)
            {
                outputData[i * outputPitch + <span class="pl-c1">4</span> * j + <span class="pl-c1">0</span>] = inputData[i * inputPitch + <span class="pl-c1">4</span> * j + <span class="pl-c1">0</span>]; <span class="pl-c">// B</span>
                outputData[i * outputPitch + <span class="pl-c1">4</span> * j + <span class="pl-c1">1</span>] = <span class="pl-c1">0</span>; <span class="pl-c">// G</span>
                outputData[i * outputPitch + <span class="pl-c1">4</span> * j + <span class="pl-c1">2</span>] = <span class="pl-c1">0</span>; <span class="pl-c">// R</span>
            }
        }
    }
}</pre></div>

<p>Raw pixel data tends to be the least common denominator of image-processing libraries. It can be used for instance to detect QR codes and barcodes using the <a href="http://www.nuget.org/packages/ZXing.Net/">ZXing.Net</a> library:</p>

<div class="highlight highlight-c#"><pre><span class="pl-k">using</span> System.Runtime.InteropServices.WindowsRuntime;

<span class="pl-s">class</span> <span class="pl-en">QrCodeDetector</span> : <span class="pl-st">IBitmapVideoEffect</span>
{
    BarcodeReader m_reader = <span class="pl-s">new</span> BarcodeReader
    {
        PossibleFormats = <span class="pl-s">new</span> BarcodeFormat[] { BarcodeFormat.QR_CODE }
    };

    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">Process</span>(<span class="pl-st">Bitmap</span> <span class="pl-vpf">input</span>, <span class="pl-st">Bitmap</span> <span class="pl-vpf">output</span>, <span class="pl-st">TimeSpan</span> <span class="pl-vpf">time</span>)
    {
        <span class="pl-c">// Pass-through effect</span>
        output.CopyDataFrom(input);

        Result result = m_reader.Decode(
            input.Buffers[<span class="pl-c1">0</span>].Buffer.ToArray(), 
            (<span class="pl-st">int</span>)input.Dimensions.Width, 
            (<span class="pl-st">int</span>)input.Dimensions.Height, 
            BitmapFormat.BGR32
            );

        Debug.WriteLine(<span class="pl-s1"><span class="pl-pds">"</span>Result: {0}<span class="pl-pds">"</span></span>, result == <span class="pl-c1">null</span> ? <span class="pl-s1"><span class="pl-pds">"</span>&lt;none&gt;<span class="pl-pds">"</span></span> : result.Text);
    }
}</pre></div>

<p>The code snippet above is fairly inefficient though (unnecessary copies/conversions, etc.) and could be improved, so if realtime detection is a scenario of interest let me know.</p>

<h2>
<a id="directx-hlsl-pixel-shader-effects" class="anchor" href="#directx-hlsl-pixel-shader-effects" aria-hidden="true"><span class="octicon octicon-link"></span></a>DirectX HLSL Pixel Shader effects</h2>

<p>Effects can process videos in either Bgra8 or Nv12 color spaces. Processing Bgra8 is simpler (one shader to write instead of two) but less efficient (the video pipeline needs to add one or two color conversions from/to Nv12/Yuy2).</p>

<p>In the case of Nv12, the luma (Y) and chroma (UV) color planes are generated separately. For instance, for a basic color-inversion effect:</p>

<pre lang="hlsl"><code>// Y processing
float4 main(Pixel pixel) : SV_Target
{
    float y = bufferY.Sample(ss, pixel.pos);
    y = 1 - y;
    return y;
}

// UV processing
float4 main(Pixel pixel) : SV_Target
{
    float4 uv = bufferUV.Sample(ss, pixel.pos);
    uv = 1 - uv;
    return uv;
}
</code></pre>

<p>Visual Studio compiles the shaders into .cso files which are included in the app package and loaded at runtime to create a video effect definition:</p>

<div class="highlight highlight-c#"><pre>    IBuffer shaderY = await PathIO.ReadBufferAsync(<span class="pl-s1"><span class="pl-pds">"</span>ms-appx:///Invert_093_NV12_Y.cso<span class="pl-pds">"</span></span>);
    IBuffer shaderUV = await PathIO.ReadBufferAsync(<span class="pl-s1"><span class="pl-pds">"</span>ms-appx:///Invert_093_NV12_UV.cso<span class="pl-pds">"</span></span>);
    <span class="pl-k">var</span> definition = <span class="pl-s">new</span> ShaderEffectDefinitionNv12(shaderY, shaderUV);

    <span class="pl-k">var</span> transcoder = <span class="pl-s">new</span> MediaTranscoder();
    transcoder.AddVideoEffect(definition.ActivatableClassId, <span class="pl-c1">true</span>, definition.Properties);</pre></div>

<p>For effects to run on Windows Phone 8.1, in the file property page 'Configuration Properties &gt; HLSL Compiler &gt; General &gt; Shader Model' must be set to 'Shader Model 4 Level 9_3 (/4_0_level_9_3)'. Visual Studio only supports compiling shaders in C++ project, so for C# app a separate C++ project should be created to compile the shaders.</p>

<p>For the .cso files to be included in the app package, in their file property page 'Build Action' must be set to 'Content'.</p>

<h2>
<a id="implementation-details" class="anchor" href="#implementation-details" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation details</h2>

<p>The meat of the code is under VideoEffects/VideoEffects/VideoEffects.Shared. It consists in three Windows Runtime Classes: VideoEffects.LumiaEffect,  VideoEffects.ShaderEffectNv12, and VideoEffects.ShaderEffectBgrx8. LumiaEffect wraps a chain of Imaging SDKâ€™s IFilter inside <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms696260">IMFTransform</a>/<a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.media.imediaextension.aspx">IMediaExtension</a>. ShaderEffectXxx wraps a precompiled DirectX HSLS pixel shader. The rest is mostly support code and unit tests. </p>

<p>The Runtime Classes must be declared in the AppxManifest files of Store apps wanting to call it:</p>

<div class="highlight highlight-xml"><pre>&lt;<span class="pl-ent">Extensions</span>&gt;
  &lt;<span class="pl-ent">Extension</span> <span class="pl-e">Category</span>=<span class="pl-s1"><span class="pl-pds">"</span>windows.activatableClass.inProcessServer<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">InProcessServer</span>&gt;
      &lt;<span class="pl-ent">Path</span>&gt;VideoEffects.WindowsPhone.dll&lt;/<span class="pl-ent">Path</span>&gt;
      &lt;<span class="pl-ent">ActivatableClass</span> <span class="pl-e">ActivatableClassId</span>=<span class="pl-s1"><span class="pl-pds">"</span>VideoEffects.LumiaEffect<span class="pl-pds">"</span></span> <span class="pl-e">ThreadingModel</span>=<span class="pl-s1"><span class="pl-pds">"</span>both<span class="pl-pds">"</span></span> /&gt;
        &lt;<span class="pl-ent">ActivatableClass</span> <span class="pl-e">ActivatableClassId</span>=<span class="pl-s1"><span class="pl-pds">"</span>VideoEffects.ShaderEffectBgrx8<span class="pl-pds">"</span></span> <span class="pl-e">ThreadingModel</span>=<span class="pl-s1"><span class="pl-pds">"</span>both<span class="pl-pds">"</span></span> /&gt;
        &lt;<span class="pl-ent">ActivatableClass</span> <span class="pl-e">ActivatableClassId</span>=<span class="pl-s1"><span class="pl-pds">"</span>VideoEffects.ShaderEffectNv12<span class="pl-pds">"</span></span> <span class="pl-e">ThreadingModel</span>=<span class="pl-s1"><span class="pl-pds">"</span>both<span class="pl-pds">"</span></span> /&gt;
    &lt;/<span class="pl-ent">InProcessServer</span>&gt;
  &lt;/<span class="pl-ent">Extension</span>&gt;
&lt;/<span class="pl-ent">Extensions</span>&gt;</pre></div>

<p>Visual Studio does not handle such an <code>&lt;Extension&gt;</code> element. The AppxManifest needs to be opened as raw XML and the XML code snippet above copy/pasted. For Windows Store apps the <code>&lt;path&gt;</code> is VideoEffects.Windows.dll. NuGet packages handle that part automatically when targeting C# Store apps.</p>

<p>Video frames are received as <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh447827">IMF2DBuffer2</a> from the Media Foundation pipeline and successively wrapped inside <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.streams.ibuffer.aspx">IBuffer</a>, Bitmap, and BitmapImageSource/BitmapRenderer to be handed to the Nokia Imaging SDK.</p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-55657833-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>